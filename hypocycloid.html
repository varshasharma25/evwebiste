<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hypocycloid | EV Lab</title>
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <div class="engineering-grid"></div>

    <div class="lab-layout">
        <aside class="sidebar">
            <a href="index.html" class="back-home">← BACK TO DASHBOARD</a>

            <h2>Hypocycloid</h2>

            <div class="instruction-box"
                style="background: rgba(0, 0, 0, 0.2); padding: 1rem; border-radius: 4px; margin-bottom: 2rem; border-left: 3px solid var(--neon-yellow);">
                <p style="font-size: 0.8rem; color: var(--text-slate);">GIVEN:</p>
                <p>Directing Circle: D = 200 mm<br>Rolling Circle: d = 50 mm</p>
            </div>

            <div class="step-info" id="stepInfo">
                <span class="step-number">READY TO START</span>
                <p class="step-desc">Click "START TUTORIAL" to begin.</p>
            </div>

            <div class="controls">
                <button class="control-btn primary" id="nextBtn" onclick="handleNext()">START TUTORIAL</button>
                <button class="control-btn" onclick="handlePrev()">PREVIOUS</button>
                <button class="control-btn" onclick="handleReset()">RESET</button>
            </div>
        </aside>

        <main class="canvas-container">
            <canvas id="constructionCanvas" width="800" height="600"></canvas>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>
        const canvas = document.getElementById('constructionCanvas');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 3; // Adjustment for larger circles

        let currentStep = 0;
        const neonYellow = '#ffff00';
        const neonGreen = '#00ff00';
        const neonRed = '#ff3131';

        function clear() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            for (let i = 0; i < canvas.width; i += 50) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke(); }
            for (let i = 0; i < canvas.height; i += 50) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(canvas.width, i); ctx.stroke(); }
        }

        const steps = [
            {
                title: "Step 1: Directing Circle",
                desc: "Draw the directing circle of radius R = 100 mm (D = 200 mm) with center O.",
                draw: () => {
                    drawCircle(centerX, centerY, 100 * scale, neonYellow, true);
                    drawPoint(centerX, centerY, 'O', neonRed);
                }
            },
            {
                title: "Step 2: Rolling Circle",
                desc: "Draw the rolling circle of radius r = 25 mm inside the directing circle, internally tangent at the top.",
                draw: () => {
                    drawCircle(centerX, centerY - (100 - 25) * scale, 25 * scale, neonYellow);
                    drawPoint(centerX, centerY - (100 - 25) * scale, 'C', neonRed);
                }
            },
            {
                title: "Step 3: Directing Arc Divisions",
                desc: "Divide a portion of the directing circle (θ = r/R * 360 = 90°) into 12 equal parts.",
                draw: () => {
                    for (let i = 0; i <= 12; i++) {
                        const ang = (i * 90 / 12 - 90) * (Math.PI / 180);
                        drawLine(centerX, centerY, centerX + Math.cos(ang) * 110 * scale, centerY + Math.sin(ang) * 110 * scale, 'rgba(136, 146, 176, 0.2)', true);
                    }
                }
            },
            {
                title: "Step 4: Rolling Circle Divisions",
                desc: "Divide the rolling circle into 12 equal parts and number them accurately.",
                draw: () => {
                    const cx = centerX;
                    const cy = centerY - 75 * scale;
                    for (let i = 0; i < 12; i++) {
                        const ang = (i * 30 - 90) * (Math.PI / 180);
                        drawPoint(cx + Math.cos(ang) * 25 * scale, cy + Math.sin(ang) * 25 * scale, '', neonYellow, 2);
                    }
                }
            },
            {
                title: "Step 5: Plotting Path",
                desc: "Trace the path of point 'P' as the circle rolls. Points are located where rolling circle centers meet division arcs.",
                draw: () => {
                    // Logic for points
                    for (let i = 0; i <= 12; i++) {
                        const theta = (i * 90 / 12 - 90) * (Math.PI / 180);
                        const phi = -(100 / 25) * (theta + Math.PI / 2);
                        const cx = centerX + (100 - 25) * scale * Math.cos(theta);
                        const cy = centerY + (100 - 25) * scale * Math.sin(theta);
                        const px = cx + 25 * scale * Math.cos(phi + Math.PI / 2);
                        const py = cy + 25 * scale * Math.sin(phi + Math.PI / 2);
                        drawPoint(px, py, '', neonRed, 2);
                    }
                }
            },
            {
                title: "Step 6: Hypocycloid Curve",
                desc: "Join the plotted points with a smooth curve to generate the Hypocycloid.",
                draw: () => {
                    ctx.beginPath();
                    ctx.strokeStyle = neonGreen;
                    ctx.lineWidth = 3;

                    const points = [];
                    for (let i = 0; i <= 12; i++) {
                        const theta = (i * 90 / 12 - 90) * (Math.PI / 180);
                        const phi = -(100 / 25) * (theta + Math.PI / 2);
                        const cx = centerX + 75 * scale * Math.cos(theta);
                        const cy = centerY + 75 * scale * Math.sin(theta);
                        const px = cx + 25 * scale * Math.cos(phi + Math.PI / 2);
                        const py = cy + 25 * scale * Math.sin(phi + Math.PI / 2);
                        points.push({ x: px, y: py });
                    }

                    gsap.to({}, {
                        duration: 3,
                        onUpdate: function () {
                            const p = this.progress();
                            clear();
                            for (let j = 0; j < currentStep; j++) steps[j].draw();
                            ctx.beginPath();
                            ctx.strokeStyle = neonGreen;
                            ctx.lineWidth = 3;
                            ctx.moveTo(points[0].x, points[0].y);
                            for (let i = 1; i < points.length * p; i++) {
                                ctx.lineTo(points[i].x, points[i].y);
                            }
                            ctx.stroke();
                        }
                    });
                }
            },
            {
                title: "Step 7: Final Result",
                desc: "HYPOCYCLOID CONSTRUCTION COMPLETE.",
                draw: () => {
                    ctx.fillStyle = neonGreen;
                    ctx.font = '24px Space Mono';
                    ctx.fillText("HYPOCYCLOID", centerX - 80, centerY + 150 * scale);
                    document.getElementById('nextBtn').innerText = "FINISH";
                    document.getElementById('nextBtn').disabled = true;
                }
            }
        ];

        function drawCircle(x, y, r, color, dashed = false) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            if (dashed) ctx.setLineDash([5, 5]);
            else ctx.setLineDash([]);
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.stroke();
        }

        function drawLine(x1, y1, x2, y2, color, dashed = false) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            if (dashed) ctx.setLineDash([5, 5]);
            else ctx.setLineDash([]);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawPoint(x, y, label, color, size = 4) {
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            if (label) {
                ctx.fillStyle = '#fff';
                ctx.fillText(label, x + 5, y - 5);
            }
        }

        function handleNext() {
            if (currentStep < steps.length) {
                steps[currentStep].draw();
                document.getElementById('stepInfo').innerHTML = `
                    <span class="step-number">STEP ${currentStep + 1}</span>
                    <p class="step-desc">${steps[currentStep].desc}</p>
                `;
                currentStep++;
                document.getElementById('nextBtn').innerText = "NEXT STEP";
            }
        }

        function handlePrev() { if (currentStep > 0) { currentStep--; redraw(); } }
        function handleReset() { currentStep = 0; redraw(); document.getElementById('nextBtn').disabled = false; }
        function redraw() { clear(); for (let i = 0; i < currentStep; i++) steps[i].draw(); }

        clear();
    </script>
</body>

</html>